const { sendResponse, catchAsync, AppError } = require("../helpers/utils");
const Order = require("../models/Order");
const Book = require("../models/Book");
const User = require("../models/User");
const Cart = require("../models/Cart");
const { StatusCodes } = require("http-status-codes");
const { v4: uuidv4 } = require("uuid");

const orderController = {};

// T·∫°o ƒë∆°n h√†ng kh√°ch ƒëƒÉng nh·∫≠p
orderController.createOrder = catchAsync(async (req, res) => {
  const { userId } = req.params;
  const { books, shippingAddress, paymentMethods } = req.body;

  // console.log("D·ªØ li·ªáu nh·∫≠n ƒë∆∞·ª£c trong req.body:", req.body);

  // 1. Ki·ªÉm tra ng∆∞·ªùi d√πng
  const user = await User.findById(userId);
  if (!user) {
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Kh√¥ng t√¨m th·∫•y ng∆∞·ªùi d√πng",
      "Create Order Error"
    );
  }

  // 2. Ki·ªÉm tra danh s√°ch s√°ch
  if (!Array.isArray(books) || books.length === 0) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      "Kh√¥ng c√≥ s√°ch trong ƒë∆°n h√†ng",
      "Create Order Error"
    );
  }

  // 3. Ki·ªÉm tra ph∆∞∆°ng th·ª©c thanh to√°n
  const validPaymentMethods = ["After receive", "PayPal"];
  const trimmedPaymentMethod = paymentMethods?.trim();
  if (
    !trimmedPaymentMethod ||
    !validPaymentMethods.includes(trimmedPaymentMethod)
  ) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      "Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng h·ª£p l·ªá",
      "Create Order Error"
    );
  }

  // 4. Ki·ªÉm tra th√¥ng tin giao h√†ng
  const requiredAddressFields = [
    "fullName",
    "phone",
    "addressLine",
    "city",
    "state",
    "ward",
    "country",
  ];

  for (const field of requiredAddressFields) {
    if (!shippingAddress || !shippingAddress[field]) {
      throw new AppError(
        StatusCodes.BAD_REQUEST,
        `Tr∆∞·ªùng "${field}" trong ƒë·ªãa ch·ªâ giao h√†ng l√† b·∫Øt bu·ªôc`,
        "Create Order Error"
      );
    }
  }

  // 5. X·ª≠ l√Ω s√°ch
  const orderedBooks = await Promise.all(
    books.map(async ({ bookId, quantity }) => {
      const book = await Book.findById(bookId);
      if (!book) {
        throw new AppError(
          StatusCodes.NOT_FOUND,
          `Kh√¥ng t√¨m th·∫•y s√°ch: ${bookId}`,
          "Create Order Error"
        );
      }

      const price = book.discountedPrice || book.price;
      return {
        bookId,
        name: book.name,
        quantity,
        price,
        total: (quantity * price).toFixed(2),
        Isbn: book.Isbn,
      };
    })
  );

  // 6. T√≠nh t·ªïng ti·ªÅn v√† ph√≠ v·∫≠n chuy·ªÉn
  const totalItemPrice = orderedBooks.reduce(
    (sum, item) => sum + parseFloat(item.total),
    0
  );
  const shippingFee = 3.0; 
  const calculatedTotalAmount = totalItemPrice + shippingFee;

  
  const paymentStatus = trimmedPaymentMethod === "PayPal" ? "ƒê√£ thanh to√°n" : "Ch∆∞a thanh to√°n";

  const cart = await Cart.findOne({ userId });
  if (cart) {
    cart.purchaseHistory = [
      ...cart.purchaseHistory,
      ...orderedBooks.map((book) => ({
        bookId: book.bookId,
        name: book.name,
        price: book.price,
        quantity: book.quantity,
        purchasedAt: new Date(),
      })),
    ];
    await cart.save();
  }

  const orderCode = `ORDER-${uuidv4()}`;

  const order = await Order.create({
    orderCode,
    userId,
    books: orderedBooks,
    shippingAddress,
    paymentMethods,
    paymentStatus,
    totalAmount: calculatedTotalAmount,
    shippingFee,
    status: "ƒêang x·ª≠ l√Ω",
    isGuestOrder: null,
  });

  sendResponse(
    res,
    StatusCodes.CREATED,
    true,
    order,
    null,
    "ƒê∆°n h√†ng ƒë∆∞·ª£c t·∫°o th√†nh c√¥ng"
  );
});

orderController.getOrdersByUserId = catchAsync(async (req, res) => {
  const orders = await Order.find({
    userId: req.params.userId,
    isDeleted: false,
  });
  sendResponse(
    res,
    StatusCodes.OK,
    true,
    orders,
    null,
    "Orders retrieved successfully"
  );
});

orderController.getOrderById = catchAsync(async (req, res) => {
  const { userId, orderId } = req.params;

  console.log("UserId nh·∫≠n ƒë∆∞·ª£c trong getOrderById:", userId);
  console.log("OrderId nh·∫≠n ƒë∆∞·ª£c trong getOrderById:", orderId);

  const order = await Order.findOne({
    userId,
    _id: orderId,
    isDeleted: false,
  }).populate({
    path: "books.bookId",
    select: "name img",
  });

  console.log("Chi ti·∫øt ƒë∆°n h√†ng t√¨m ƒë∆∞·ª£c:", order);

  if (!order) {
    console.error("Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng v·ªõi OrderId:", orderId);
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Order not found",
      "Get Order Error"
    );
  }

  const populatedOrder = {
    ...order.toObject(),
    books: order.books.map((book) => ({
      bookId: book.bookId?._id || book.bookId,
      name: book.bookId?.name || book.name,
      img: book.bookId?.img || "/default-book.jpg",
      quantity: book.quantity,
      price: book.price,
      total: book.total,
      Isbn: book.Isbn || book.bookId?.Isbn || "N/A",
    })),
  };

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    populatedOrder,
    null,
    "Order retrieved successfully"
  );
});

// Cancel ƒë∆°n h√†ng
orderController.updateOrderByUser = catchAsync(async (req, res) => {
  const { userId, orderId } = req.params;
  const { status } = req.body;

  const order = await Order.findOne({ userId, _id: orderId, isDeleted: false });

  if (!order) {
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Order not found",
      "Update Order Error"
    );
  }

  if (!["ƒêang x·ª≠ l√Ω", "ƒê√£ giao h√†ng"].includes(order.status)) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      "Only orders in 'ƒêang x·ª≠ l√Ω' or 'ƒê√£ giao h√†ng' status can be cancelled",
      "Update Order Error"
    );
  }

  order.status = "ƒê√£ h·ªßy";

  if (order.paymentStatus === "ƒê√£ thanh to√°n") {
    order.paymentStatus = "ƒê√£ ho√†n ti·ªÅn";
  }

  await order.save();

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    order,
    null,
    "Order cancelled successfully"
  );
});


orderController.getAllOrders = catchAsync(async (req, res) => {
  const { search, searchCriteria } = req.query;
  const query = { isDeleted: false };

  if (search && searchCriteria) {
    if (searchCriteria === "books.Isbn") {
      query["books.Isbn"] = { $regex: search, $options: "i" };
    } else if (searchCriteria === "customerName") {
      query["shippingAddress.fullName"] = { $regex: search, $options: "i" };
    } else {
      query[searchCriteria] = { $regex: search, $options: "i" };
    }
  }
  const orders = await Order.find(query);
  sendResponse(
    res,
    StatusCodes.OK,
    true,
    orders,
    null,
    "Orders retrieved successfully"
  );
});

orderController.updateOrderAD = catchAsync(async (req, res) => {
  const { status } = req.body;
  const orderId = req.params.orderId;

  const order = await Order.findOne({
    _id: orderId,
    isDeleted: false,
  });

  if (!order) {
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng",
      "L·ªói c·∫≠p nh·∫≠t ƒë∆°n h√†ng"
    );
  }

  const currentStatus = order.status.trim();
  const newStatus = status.trim();

  console.log(`üöÄ C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng t·ª´: '${currentStatus}' ‚Üí '${newStatus}'`);

  if (currentStatus === newStatus) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      `Tr·∫°ng th√°i ƒë√£ l√† '${newStatus}', kh√¥ng c·∫ßn c·∫≠p nh·∫≠t`,
      "L·ªói c·∫≠p nh·∫≠t ƒë∆°n h√†ng"
    );
  }

  const validTransitions = {
    "ƒêang x·ª≠ l√Ω": ["ƒê√£ giao h√†ng", "ƒê√£ nh·∫≠n h√†ng", "ƒê√£ h·ªßy"],
    "ƒê√£ giao h√†ng": ["ƒê√£ nh·∫≠n h√†ng", "Tr·∫£ h√†ng", "ƒê√£ h·ªßy"],
    "ƒê√£ nh·∫≠n h√†ng": ["Tr·∫£ h√†ng", "ƒê√£ h·ªßy"],
    "Tr·∫£ h√†ng": [],
    "ƒê√£ h·ªßy": []
  };

  if (!validTransitions[currentStatus]) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      `Tr·∫°ng th√°i hi·ªán t·∫°i '${currentStatus}' kh√¥ng h·ª£p l·ªá`,
      "L·ªói c·∫≠p nh·∫≠t ƒë∆°n h√†ng"
    );
  }

  if (!validTransitions[currentStatus].includes(newStatus)) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      `Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i t·ª´ '${currentStatus}' sang '${newStatus}'`,
      "L·ªói c·∫≠p nh·∫≠t ƒë∆°n h√†ng"
    );
  }

  if (status === "ƒê√£ h·ªßy" && order.paymentStatus === "ƒê√£ thanh to√°n") {
    console.log(`üîÑ ƒê∆°n h√†ng b·ªã h·ªßy - t·ª± ƒë·ªông ho√†n ti·ªÅn t·ª´ '${order.paymentStatus}' ‚Üí 'ƒê√£ ho√†n ti·ªÅn'`);
    order.paymentStatus = "ƒê√£ ho√†n ti·ªÅn";
  }

  order.status = newStatus;
  if (newStatus === "Tr·∫£ h√†ng" && order.paymentStatus === "ƒê√£ thanh to√°n") {
    console.log("üîÑ ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c tr·∫£ h√†ng, t·ª± ƒë·ªông chuy·ªÉn tr·∫°ng th√°i thanh to√°n th√†nh 'ƒê√£ ho√†n ti·ªÅn'");
    order.paymentStatus = "ƒê√£ ho√†n ti·ªÅn";
  }
  await order.save();

  console.log("‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i th√†nh c√¥ng!");

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    order,
    null,
    "C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh c√¥ng"
  );
});


orderController.deleteOrder = catchAsync(async (req, res) => {
  const order = await Order.findOneAndUpdate(
    { userId: req.params.userId, _id: req.params.orderId, isDeleted: false },
    { isDeleted: true },
    { new: true }
  );

  if (!order)
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Order not found",
      "Delete Order Error"
    );

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    null,
    null,
    "Order deleted successfully"
  );
});

orderController.updatePaymentStatus = catchAsync(async (req, res) => {
  const { orderId } = req.params;
  const { paymentStatus } = req.body;

  const order = await Order.findOne({ _id: orderId, isDeleted: false });

  if (!order) {
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng",
      "L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n"
    );
  }

  const currentPaymentStatus = order.paymentStatus.trim();
  const newPaymentStatus = paymentStatus.trim();


  const validTransitions = {
    "Ch∆∞a thanh to√°n": ["ƒê√£ thanh to√°n"], 
    "ƒê√£ thanh to√°n": ["ƒê√£ ho√†n ti·ªÅn"], 
    "ƒê√£ ho√†n ti·ªÅn": [] 
  };

  const shouldAutoRefund = ["Tr·∫£ h√†ng", "ƒê√£ h·ªßy"].includes(order.status) && currentPaymentStatus === "ƒê√£ thanh to√°n";

  if (shouldAutoRefund) {
    order.paymentStatus = "ƒê√£ ho√†n ti·ªÅn";
  } else {
    if (!validTransitions[currentPaymentStatus].includes(newPaymentStatus)) {
      throw new AppError(
        StatusCodes.BAD_REQUEST,
        `Kh√¥ng th·ªÉ c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n t·ª´ '${currentPaymentStatus}' sang '${newPaymentStatus}'`,
        "L·ªói c·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n"
      );
    }
    order.paymentStatus = newPaymentStatus;
  }

  await order.save();
  console.log("‚úÖ C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n th√†nh c√¥ng!");

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    order,
    null,
    "C·∫≠p nh·∫≠t tr·∫°ng th√°i thanh to√°n th√†nh c√¥ng"
  );
});

orderController.getOrdersByStatus = catchAsync(async (req, res) => {
  const { status } = req.params;
  const orders = await Order.find({ status, isDeleted: false });

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    orders,
    null,
    `Orders with status ${status} retrieved successfully`
  );
});

orderController.trackOrderStatus = catchAsync(async (req, res) => {
  const order = await Order.findOne({
    _id: req.params.orderId,
    userId: req.user.id,
    isDeleted: false,
  });

  if (!order)
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Order not found",
      "Track Order Status Error"
    );

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    { status: order.status },
    null,
    "Order status retrieved successfully"
  );
});

orderController.updateShippingAddress = catchAsync(async (req, res) => {
  const { userId, orderId } = req.params;
  const { shippingAddress } = req.body;
  let order;

  if (req.user.role === "customer") {
    order = await Order.findOne({
      _id: orderId,
      userId: req.user._id, 
      status: "ƒêang x·ª≠ l√Ω", 
      isDeleted: false,
    });
  } else if (req.user.role === "admin") {
    order = await Order.findOne({
      _id: orderId,
      status: "ƒêang x·ª≠ l√Ω", 
      isDeleted: false,
    });
  }

  if (!order) {
    console.error("‚ùå Order not found or not eligible for address change", {
      orderId,
      userId: req.user.role === "customer" ? req.userId : "N/A",
    });
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng ho·∫∑c kh√¥ng th·ªÉ thay ƒë·ªïi ƒë·ªãa ch·ªâ",
      "L·ªói c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng"
    );
  }

  const requiredFields = [
    "fullName",
    "phone",
    "addressLine",
    "city",
    "state",
    "country",
  ];
  for (const field of requiredFields) {
    if (!shippingAddress[field]?.trim()) {
      console.error(
        "‚ùå Thi·∫øu tr∆∞·ªùng:",
        field,
        "trong ƒë·ªãa ch·ªâ giao h√†ng:",
        shippingAddress
      );
      throw new AppError(
        StatusCodes.BAD_REQUEST,
        `Thi·∫øu tr∆∞·ªùng ${field} trong ƒë·ªãa ch·ªâ giao h√†ng`,
        "L·ªói c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng"
      );
    }
  }

  if (!shippingAddress.zipcode) {
    shippingAddress.zipcode = "";
  }

  order.shippingAddress = shippingAddress;
  await order.save();

  // console.log("‚úÖ ƒê√£ c·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng:", order.shippingAddress);

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    order,
    null,
    "C·∫≠p nh·∫≠t ƒë·ªãa ch·ªâ giao h√†ng th√†nh c√¥ng"
  );
});


orderController.addOrderFeedback = catchAsync(async (req, res) => {
  const { feedback } = req.body;
  const order = await Order.findOneAndUpdate(
    {
      _id: req.params.orderId,
      userId: req.user.id,
      status: "ƒê√£ nh·∫≠n h√†ng",
      isDeleted: false,
    },
    { feedback },
    { new: true }
  );

  if (!order)
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Order not found or not eligible for feedback",
      "Add Order Feedback Error"
    );

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    order,
    null,
    "Feedback added successfully"
  );
});

//t·∫°o ƒë∆°n h√†ng kh√°ch kh√¥ng ƒëƒÉng nh·∫≠p
orderController.createGuestOrder = catchAsync(async (req, res) => {
  const { books, shippingAddress, paymentMethods } = req.body;

  // 1. Ki·ªÉm tra danh s√°ch s√°ch
  if (!Array.isArray(books) || books.length === 0) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      "No books in the order",
      "Create Guest Order Error"
    );
  }

  // 2. Ki·ªÉm tra th√¥ng tin giao h√†ng
  const requiredFields = [
    "fullName",
    "phone",
    "addressLine",
    "city",
    "state",
    // "zipcode",
    "country",
  ];
  for (const field of requiredFields) {
    if (!shippingAddress || !shippingAddress[field]) {
      throw new AppError(
        StatusCodes.BAD_REQUEST,
        `Field "${field}" is required in shippingAddress`,
        "Create Guest Order Error"
      );
    }
  }

  // 3. Ki·ªÉm tra ph∆∞∆°ng th·ª©c thanh to√°n
  const validPaymentMethods = ["After receive", "PayPal"];
  const trimmedPaymentMethod = paymentMethods?.trim();
  if (
    !trimmedPaymentMethod ||
    !validPaymentMethods.includes(trimmedPaymentMethod)
  ) {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      "Ph∆∞∆°ng th·ª©c thanh to√°n kh√¥ng h·ª£p l·ªá",
      "Create Order Error"
    );
  }

  // 4. X·ª≠ l√Ω danh s√°ch s√°ch
  const orderedBooks = await Promise.all(
    books.map(async ({ bookId, quantity }) => {
      const book = await Book.findById(bookId);
      if (!book) {
        throw new AppError(
          StatusCodes.NOT_FOUND,
          `Book not found: ${bookId}`,
          "Create Guest Order Error"
        );
      }

      const price = book.discountedPrice || book.price;
      return {
        bookId,
        name: book.name,
        img: book.img,
        Isbn: book.Isbn,
        quantity,
        price,
        total: (quantity * price).toFixed(2),
      };
    })
  );

  // 5. T√≠nh t·ªïng ti·ªÅn v√† ph√≠ v·∫≠n chuy·ªÉn
  const totalItemPrice = orderedBooks.reduce(
    (sum, book) => sum + parseFloat(book.total),
    0
  );
  const shippingFee = 3.0; // Ph√≠ v·∫≠n chuy·ªÉn c·ªë ƒë·ªãnh
  const totalAmount = totalItemPrice + shippingFee;

  const paymentStatus = trimmedPaymentMethod === "PayPal" ? "ƒê√£ thanh to√°n" : "Ch∆∞a thanh to√°n";

  // 6. T·∫°o m√£ ƒë∆°n h√†ng
  const orderCode = `GUEST-${uuidv4()}`;

  // 7. L∆∞u ƒë∆°n h√†ng v√†o c∆° s·ªü d·ªØ li·ªáu
  const newOrder = await Order.create({
    orderCode,
    books: orderedBooks,
    shippingAddress,
    paymentMethods,
    paymentStatus,
    status: "ƒêang x·ª≠ l√Ω",
    shippingFee,
    totalAmount,
    isGuestOrder: true,
    userId: null,
  });
  console.log("üì¶ ƒê∆°n h√†ng kh√°ch v√£ng lai:", newOrder);


  // 8. Ph·∫£n h·ªìi
  sendResponse(
    res,
    StatusCodes.CREATED,
    true,
    { ...newOrder.toObject(), orderCode },
    null,
    "Guest order created successfully"
  );
});

orderController.getOrderByCode = catchAsync(async (req, res) => {
  const { orderCode } = req.params; 

  if (!orderCode) {
    return res.status(400).json({
      success: false,
      message: "Order code is required",
    });
  }

  console.log("üîç ƒêang t√¨m ƒë∆°n h√†ng v·ªõi m√£:", orderCode);

  try {
    const order = await Order.findOne({ orderCode }).populate(
      "books.bookId",
      "name img price"
    );

    if (!order) {
      console.error("‚ùå Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng:", orderCode);
      return res.status(404).json({
        success: false,
        message: "Order not found",
      });
    }

    return res.status(200).json({
      success: true,
      data: order,
      message: "Order retrieved successfully",
    });
  } catch (error) {
    console.error("üî• L·ªói khi t√¨m ƒë∆°n h√†ng:", error);
    return res.status(500).json({
      success: false,
      message: "Internal server error",
    });
  }
});


//l·∫•y ƒë∆°n h√†ng cho kh√°ch kh√¥ng ƒëƒÉng nh·∫≠p
orderController.getGuestOrderByCode = async (req, res) => {
  try {
      const { orderCode } = req.params;

      const order = await Order.findOne({ orderCode, isGuestOrder: true })
      .populate({
          path: "books.bookId",
          model: "Book", 
          select: "name img price", 
      });

      if (!order) {
          return res.status(404).json({ message: "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng" });
      }

      return res.status(200).json(order);
  } catch (error) {
      console.error("Error fetching guest order:", error);
      return res.status(500).json({ message: "L·ªói server" });
  }
};

// L·∫•y l·ªãch s·ª≠ mua h√†ng
orderController.getPurchaseHistory = catchAsync(async (req, res) => {
  const userId = req.params.userId || req.userId;
  // console.log("UserId nh·∫≠n ƒë∆∞·ª£c trong getPurchaseHistory:", userId);

  const orders = await Order.find({ userId })
    .populate({
      path: "books.bookId",
      select: "name img",
    })
    .exec();
  // console.log("L·ªãch s·ª≠ mua h√†ng: *******", orders);

  if (!orders || orders.length === 0) {
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "No purchase history found for the user",
      "Get Purchase History Error"
    );
  }

  const ordersWithUserId = orders.map((order) => ({
    ...order.toObject(),
    userId,
  }));

  sendResponse(
    res,
    StatusCodes.OK,
    true,
    ordersWithUserId,
    null,
    "Purchase history retrieved successfully"
  );
});


orderController.cancelGuestOrder = catchAsync(async (req, res) => {
  const { orderCode } = req.params;

  // 1. Ki·ªÉm tra ƒë∆°n h√†ng c√≥ t·ªìn t·∫°i kh√¥ng
  const order = await Order.findOne({ orderCode, isGuestOrder: true });

  if (!order) {
    throw new AppError(
      StatusCodes.NOT_FOUND,
      "Kh√¥ng t√¨m th·∫•y ƒë∆°n h√†ng d√†nh cho kh√°ch ch∆∞a ƒëƒÉng nh·∫≠p",
      "Cancel Guest Order Error"
    );
  }

  // 2. Ki·ªÉm tra tr·∫°ng th√°i ƒë∆°n h√†ng, ch·ªâ cho ph√©p h·ªßy khi ƒëang x·ª≠ l√Ω
  if (order.status !== "ƒêang x·ª≠ l√Ω") {
    throw new AppError(
      StatusCodes.BAD_REQUEST,
      "Ch·ªâ c√≥ th·ªÉ h·ªßy ƒë∆°n h√†ng khi ƒëang trong tr·∫°ng th√°i 'ƒêang x·ª≠ l√Ω'",
      "Cancel Guest Order Error"
    );
  }

  // 3. C·∫≠p nh·∫≠t tr·∫°ng th√°i ƒë∆°n h√†ng th√†nh "ƒê√£ h·ªßy"
  order.status = "ƒê√£ h·ªßy";
  order.updatedAt = new Date();
  await order.save();

  // 4. Tr·∫£ v·ªÅ k·∫øt qu·∫£
  sendResponse(
    res,
    StatusCodes.OK,
    true,
    order,
    null,
    "ƒê∆°n h√†ng ƒë√£ ƒë∆∞·ª£c h·ªßy th√†nh c√¥ng"
  );
});


module.exports = orderController;
